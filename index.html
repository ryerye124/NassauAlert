<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nassau Alerts Command Center</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
  body { margin: 0; font-family: Arial, sans-serif; background: #111; color: #fff; display: flex; flex-direction: column; min-height: 100vh; }

  /* HEADER */
  header { display: flex; justify-content: space-between; align-items: center; background: #222; padding: 10px 20px; position: sticky; top: 0; z-index: 1000; font-weight: bold; }
  header div { min-width: 150px; text-align: center; }

  /* CRITICAL BAR (between header and ticker) */
  .critical-wrap { overflow: hidden; background: #4a0000; height: 30px; position: sticky; top: 50px; z-index: 9999; border-bottom: 1px solid #660000; }
  .critical { display: flex; align-items: center; justify-content: center; gap: 18px; padding: 0 12px; color: #fff; line-height: 30px; font-weight: 700; letter-spacing: 0.2px; }
  .critical .chip { display: inline-flex; align-items: center; gap: 8px; background: #220000; padding: 3px 10px; border-radius: 999px; border: 1px solid #660000; }
  @keyframes critFlash { 0% { filter: brightness(1); } 50% { filter: brightness(2.2); } 100% { filter: brightness(1); } }
  .critical.flash-twice { animation: critFlash 0.6s ease-in-out 2; }

  /* TICKER */
  .ticker-wrap { overflow: hidden; background: #333; height: 30px; position: sticky; top: 80px; z-index: 999; }
  .ticker { display: inline-block; white-space: nowrap; padding-left: 100%; animation: scroll 45s linear infinite; color: #ffcc00; line-height: 30px; }
  @keyframes scroll { 0% { transform: translateX(0%); } 100% { transform: translateX(-100%); } }

  /* MAIN GRID */
main {
  flex: 1;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: 2fr 1fr;
  gap: 10px;
  padding: 10px;
  /* header(50) + critical(30) + ticker(30) = 110px */
  height: calc(100vh - 110px);
}

/* Make sure Leaflet has real pixels to work with */
#alertMap { flex: 1 1 auto; min-height: 260px; width: 100%; }
.leaflet-container { width: 100%; height: 100%; }


  /* Bulletin card (replaces radio feeds) */
  .bulletin-body {
    height: 100%;
    overflow: auto;
    padding: 8px 10px;
    background: #1a1a1a;
    border-radius: 8px;
    line-height: 1.35;
    white-space: pre-line;       /* keep your line breaks */
  }
  .bulletin-body a { color: #ffcc00; text-decoration: underline; }
  .bulletin-body ul { margin: 6px 0 6px 18px; }
  .bulletin-body p { margin: 6px 0; }

  /* Map icon (SVG) for criticals */
  .leaflet-div-icon.crit-icon { background: transparent; border: none; }
  .crit-icon svg { width: 28px; height: 34px; display: block; filter: drop-shadow(0 0 2px #000); }

  /* RESPONSIVE */
  @media (max-width: 1024px) {
    main { grid-template-columns: repeat(2, 1fr); grid-template-rows: 2fr 1fr 1fr; }
    .card:nth-child(4) { grid-column: span 2; } /* bulletin */
    .card:nth-child(5) { grid-column: span 2; } /* map */
  }
  @media (max-width: 600px) {
    main { grid-template-columns: 1fr; grid-template-rows: repeat(5, 1fr); }
    .card { grid-column: span 1; }
  }
  /* Make map card a column so the map fills under the title */
.card { display: flex; flex-direction: column; }

.card h2 { flex: 0 0 auto; }

/* The map needs an explicit height to render */
#alertMap {
  flex: 1 1 auto;      /* fill the remaining space in the card */
  min-height: 260px;   /* safety for smaller screens */
  width: 100%;
}

</style>
</head>
<body>

<header>
  <div id="est-time">EST: --:--:--</div>
  <div>Nassau Alerts</div>
  <div id="zulu-time">Zulu: --:--:--</div>
</header>

<div class="critical-wrap">
  <div class="critical" id="criticalBar">No critical alerts.</div>
</div>

<div class="ticker-wrap">
  <div class="ticker" id="ticker">Loading alerts...</div>
</div>

<main>
  <div class="card">
    <h2>Radar (NWS)</h2>
    <iframe src="https://radar.weather.gov/ridge/standard/NORTHEAST_loop.gif"></iframe>
  </div>

  <div class="card">
    <h2>Fire & Smoke Map (NWS)</h2>
    <iframe src="https://radar.weather.gov/"></iframe>
  </div>

  <div class="card">
    <h2>NY Wildfire Tracker</h2>
    <iframe src="https://www.mapofire.com/state/new-york"></iframe>
  </div>

  <!-- REPLACED: Radio card -> Bulletin card -->
 <div class="card">
  <h2 style="display:flex;align-items:center;justify-content:space-between;">
    <span>Note Pad</span>
    <span class="bulletin-toolbar" style="display:inline-flex;gap:8px;align-items:center;font-weight:normal;">
      <button id="bulletinSave" style="background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:4px 8px;cursor:pointer;">Save</button>
      <button id="bulletinRevert" style="background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:4px 8px;cursor:pointer;">Revert</button>
      <button id="bulletinClear" style="background:#552222;color:#fff;border:1px solid #774444;border-radius:6px;padding:4px 8px;cursor:pointer;">Clear</button>
      <span id="bulletinStatus" style="color:#aaa;font-size:12px;"></span>
    </span>
  </h2>

  <!-- Make this editable -->
  <div id="bulletin" class="bulletin-body" contenteditable="true">
    Welcome to the Nassau Alerts Command Center.

    • This space is editable by you! Use it for notes, or reminders.
    • You can put links here: https://www.weather.gov/
    • Basic formatting is supported (line breaks, lists).

    Stay safe.
  </div>
</div>


  <div class="card">
    <h2>Alert Map</h2>
    <div id="alertMap"></div>
  </div>
</main>

<footer>
  The information displayed and broadcasted is publicly available. 
  The site owner does not own the information. 
  The BRYX feed is made possible with continued access, granted by local departments. 
  Email <a href="mailto:alertsnassau@gmail.com">alertsnassau@gmail.com</a> to add your department!
</footer>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  /* ===== GLOBAL CONFIG & HELPERS ===== */
  const TTL_MS = 15 * 60 * 1000;   // keep items for 15 minutes

  function parseTs(s) {
    if (!s) return NaN;
    const cleaned = String(s).trim().replace(/(\.\d{3})\d+$/, '$1');
    const isoGuess = cleaned.includes('T') ? cleaned : cleaned.replace(' ', 'T');
    const hasTZ = /[zZ]|[+\-]\d{2}:?\d{2}$/.test(isoGuess);
    const finalStr = hasTZ ? isoGuess : isoGuess + 'Z';
    const t = Date.parse(finalStr);
    return Number.isNaN(t) ? Date.parse(cleaned) : t;
  }
  const fmtTime = (v) => {
    const ms = typeof v === 'number' ? v : parseTs(v);
    return Number.isNaN(ms)
      ? '—'
      : new Date(ms).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
  };
  function cacheBusted(url) {
    const sep = url.includes('?') ? '&' : '?';
    return `${url}${sep}_cb=${Date.now()}`;
  }

  /* ===== CLOCKS ===== */
  function updateClocks() {
    const est = new Date().toLocaleString("en-US", { timeZone: "America/New_York", hour12: false });
    const zulu = new Date().toISOString().substring(11,19) + "Z";
    document.getElementById("est-time").textContent = "EST: " + est;
    document.getElementById("zulu-time").textContent = "Zulu: " + zulu;
  }
  setInterval(updateClocks, 1000);
  updateClocks();

/* ===== MAP ===== */
const map = L.map('alertMap').setView([40.7, -73.6], 10);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
const markersLayer = L.layerGroup().addTo(map);

/* NEW: help Safari/Firefox measure the map after layout settles */
const mapEl = document.getElementById('alertMap');
requestAnimationFrame(() => map.invalidateSize());     // first paint
setTimeout(() => map.invalidateSize(), 250);           // after fonts/layout
map.on('load', () => map.invalidateSize());            // once tiles kick in
window.addEventListener('resize', () => map.invalidateSize());

if ('ResizeObserver' in window) {
  const ro = new ResizeObserver(() => map.invalidateSize());
  ro.observe(mapEl);
}

  // Critical alerts use a crisp SVG flame marker
  const fireIcon = L.divIcon({
    className: 'crit-icon leaflet-div-icon',
    html: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <defs>
          <linearGradient id="flameGrad" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#FFA726"/>
            <stop offset="60%" stop-color="#FB8C00"/>
            <stop offset="100%" stop-color="#E53935"/>
          </linearGradient>
        </defs>
        <path fill="url(#flameGrad)" d="M32 4c8 10-4 16-4 26 0 8 8 12 8 20 0 8-6 14-14 14-10 0-18-8-18-20 0-12 10-18 16-26 6-8 4-12 12-14z"/>
        <path fill="#FFE082" d="M26 40c4 4 2 8 0 10-2 2-6 2-8-2-2-4 2-8 8-8z"/>
        <circle cx="41" cy="15" r="3" fill="#FFCC80"/>
      </svg>
    `,
    iconSize: [28, 34],
    iconAnchor: [14, 17]
  });

  /* ===== FEED ENDPOINTS ===== */
  const BASE_URL = 'https://script.google.com/macros/s/AKfycbwjKKxg6mqOkjyZnUq2p4g2osIpTUlPKjlUg4RXFpj2W6u48sLnxjUlf7nN9ws394Zp/exec';
  const ALERTS_URL = `${BASE_URL}?limit=100`;                    // normal
  const CRIT_URL   = `${BASE_URL}?channel=critical&limit=40`;   // critical
  const POLL_MS = 20000;

  /* ===== NORMAL FEED (ticker + map) ===== */
  const live = new Map(); // id -> { marker, expiresAt, tickerSpan }
  const tickerEl = document.getElementById('ticker');

  function colorFor(a) {
    const cat = (a.category||'').toLowerCase();
    const call = (a.callType||'').toLowerCase();
    if (cat.includes('fire') || call.includes('fire')) return 'red';
    if (cat.includes('ems') || call.includes('ambulance')) return 'blue';
    return 'yellow';
  }
  function makeTickerSpan(a, color) {
    const dot = document.createElement('span');
    dot.style.cssText = 'display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;background:'+color;
    const text = document.createElement('span');
    text.textContent = `${(a.category||'').toUpperCase()} • ${a.location||''}${a.city? ', '+a.city:''} • ${fmtTime(a.eventTimestamp)}`;
    const wrap = document.createElement('span');
    wrap.style.marginRight = '40px';
    wrap.append(dot, text);
    return wrap;
  }
  function makeMarker(lat, lng, color, a) {
    return L.circleMarker([lat, lng], {
      radius: 8, color, weight: 2, fillColor: color, fillOpacity: 0.85
    }).bindTooltip(
      `${(a.category||'').toUpperCase()}<br>${a.location||''}${a.city? ', '+a.city:''}<br>${fmtTime(a.eventTimestamp)}`,
      {direction:'top', offset:[0,-8]}
    ).addTo(markersLayer);
  }
  function makeFireMarker(lat, lng, a) {
    return L.marker([lat, lng], { icon: fireIcon })
      .bindTooltip(
        `${(a.category||'CRITICAL').toUpperCase()}<br>${a.location||''}${a.city? ', '+a.city:''}<br>${fmtTime(a.eventTimestamp)}`,
        { direction: 'top', offset: [0, -8] }
      )
      .addTo(markersLayer);
  }
  function cleanupExpired() {
    const now = Date.now();
    for (const [id, obj] of live) {
      if (obj.expiresAt <= now) {
        if (obj.marker && map.hasLayer(obj.marker)) map.removeLayer(obj.marker);
        obj.tickerSpan?.remove();
        live.delete(id);
      }
    }
    if (live.size === 0 && !tickerEl.dataset.placeholderShown) {
      tickerEl.textContent = 'No recent alerts.';
      tickerEl.dataset.placeholderShown = '1';
    }
  }

  async function fetchAlertsOnce() {
    const res = await fetch(cacheBusted(ALERTS_URL), { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const json = await res.json();
    return (json.results || []).map(r => ({
      id: r.uniqueKey || `${r.incidentId || ''}-${r.eventTimestamp || ''}`,
      category: r.category,
      callType: r.callType,
      location: r.location,
      city: r.city,
      eventTimestamp: r.eventTimestamp,
      lat: r.lat != null ? Number(r.lat) : null,
      lng: r.lng != null ? Number(r.lng) : null
    })).filter(x => !Number.isNaN(parseTs(x.eventTimestamp)));
  }

  let timer = null, cleanupTimer = null;

  async function tick() {
    try {
      const alerts = await fetchAlertsOnce();
      alerts.sort((a,b)=> parseTs(b.eventTimestamp) - parseTs(a.eventTimestamp));
      tickerEl.dataset.placeholderShown = '';

      const now = Date.now();
      for (const a of alerts) {
        const id = a.id;
        const tsMs = parseTs(a.eventTimestamp);
        const exp = Math.max(now, (Number.isNaN(tsMs) ? now : tsMs) + TTL_MS);

        if (live.has(id)) {
          live.get(id).expiresAt = Math.max(live.get(id).expiresAt, exp);
          continue;
        }

        const color = colorFor(a);
        const chip  = makeTickerSpan(a, color);
        tickerEl.insertBefore(chip, tickerEl.firstChild);

        let marker = null;
        if (typeof a.lat === 'number' && typeof a.lng === 'number' && isFinite(a.lat) && isFinite(a.lng)) {
          marker = makeMarker(a.lat, a.lng, color, a);
        }

        live.set(id, { marker, tickerSpan: chip, expiresAt: exp });

        // Geocode if missing coords (normal feed)
        if (marker == null) {
          maybeGeocodeAndDropPin_Normal(a, id);
        }
      }

      cleanupExpired();
    } catch (err) {
      console.error('BRYX fetch failed:', err);
    }
  }

  function startPolling() {
    if (timer) return;
    tick(); // immediate
    timer = setInterval(tick, POLL_MS);
    if (!cleanupTimer) cleanupTimer = setInterval(cleanupExpired, 10000);
  }
  function stopPolling() { clearInterval(timer); timer = null; }

  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') startPolling();
    else stopPolling();
  });

  /* ===== CRITICAL FEED (title bar with beep/flash + fire pins) ===== */
  function beep(times = 2, durationMs = 140, gapMs = 120, freq = 880) {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      let when = ctx.currentTime;
      for (let i = 0; i < times; i++) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.001, when);
        gain.gain.exponentialRampToValueAtTime(0.3, when + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, when + durationMs/1000);
        osc.connect(gain).connect(ctx.destination);
        osc.start(when);
        osc.stop(when + durationMs/1000);
        when += (durationMs + gapMs)/1000;
      }
      setTimeout(() => ctx.close(), (times*(durationMs+gapMs))+200);
    } catch {}
  }

  const criticalBar = document.getElementById('criticalBar');
  const critLive = new Map(); // id -> { el, marker, expiresAt }

  function makeCritChip(a) {
    const dot = document.createElement('span');
    dot.style.cssText = 'display:inline-block;width:10px;height:10px;border-radius:50%;background:#ff3b3b;';
    const txt = document.createElement('span');
    const parts = [
      (a.category || 'CRITICAL').toUpperCase(),
      (a.callType || '').trim(),
      `${a.location || ''}${a.city ? ', ' + a.city : ''}`,
      fmtTime(a.eventTimestamp)
    ].filter(Boolean);
    txt.textContent = parts.join(' • ');
    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.append(dot, txt);
    return chip;
  }

  async function fetchCriticalOnce() {
    const res = await fetch(cacheBusted(CRIT_URL), { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP '+res.status);
    const json = await res.json();
    return (json.results || []).map(r => ({
      id: r.uniqueKey || `${r.eventTimestamp||''}-${r.location||''}`,
      category: r.category,
      callType: r.callType,
      location: r.location,
      city: r.city,
      eventTimestamp: r.eventTimestamp,
      lat: r.lat != null ? Number(r.lat) : null,
      lng: r.lng != null ? Number(r.lng) : null
    })).filter(x => x.eventTimestamp);
  }

  function cleanupCritical() {
    const now = Date.now();
    for (const [id, obj] of critLive) {
      if (obj.expiresAt <= now) {
        obj.el?.remove();
        if (obj.marker && map.hasLayer(obj.marker)) map.removeLayer(obj.marker);
        critLive.delete(id);
      }
    }
    if (critLive.size === 0) {
      criticalBar.textContent = 'No critical alerts.';
    }
  }

  async function tickCritical() {
    try {
      const items = await fetchCriticalOnce();
      items.sort((a,b) => parseTs(b.eventTimestamp) - parseTs(a.eventTimestamp));

      let introduced = 0;
      const now = Date.now();

      for (const a of items) {
        const id = a.id;
        const tsMs = parseTs(a.eventTimestamp);
        const exp = Math.max(now, (Number.isNaN(tsMs) ? now : tsMs) + TTL_MS);
        if (critLive.has(id)) {
          critLive.get(id).expiresAt = Math.max(critLive.get(id).expiresAt, exp);
          continue;
        }
        if (criticalBar.textContent === 'No critical alerts.') criticalBar.textContent = '';

        const chip = makeCritChip(a);
        criticalBar.insertBefore(chip, criticalBar.firstChild);

        let marker = null;
        if (typeof a.lat === 'number' && typeof a.lng === 'number' && isFinite(a.lat) && isFinite(a.lng)) {
          marker = makeFireMarker(a.lat, a.lng, a);
        }

        critLive.set(id, { el: chip, marker, expiresAt: exp });

        // Geocode if missing coords (critical feed)
        if (marker == null) {
          maybeGeocodeAndDropPin_Critical(a, id);
        }

        introduced++;
      }

      if (introduced > 0) {
        criticalBar.classList.remove('flash-twice');
        void criticalBar.offsetWidth;
        criticalBar.classList.add('flash-twice');
        beep(2, 140, 120, 988);
        criticalBar.addEventListener('animationend', () => {
          criticalBar.classList.remove('flash-twice');
        }, { once: true });
      }

      cleanupCritical();
    } catch (e) {
      console.error('Critical fetch failed:', e);
    }
  }

  /* ===== Geocoding (single copy) ===== */
  const GEOCODE_RATE_MS = 1200;
  const GEOCODE_TTL_MS  = 7 * 24 * 60 * 60 * 1000;  // 7 days cache
  const GEOCODE_BOUNDS  = { minLon: -73.90, minLat: 40.50, maxLon: -73.40, maxLat: 40.90 };

  const geoCache = {
    get(key) {
      try {
        const raw = localStorage.getItem('geo_'+key);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || (obj.t && (Date.now()-obj.t) > GEOCODE_TTL_MS)) return null;
        return obj;
      } catch { return null; }
    },
    set(key, lat, lng) {
      try { localStorage.setItem('geo_'+key, JSON.stringify({lat,lng,t:Date.now()})); } catch {}
    }
  };

  const geocodeQueue = []; // items: { key, query, onResult }
  let geocodeTimer = null;

  function enqueueGeocode(key, query, onResult) {
    if (geocodeQueue.find(q => q.key === key)) return;
    geocodeQueue.push({ key, query, onResult });
    if (!geocodeTimer) geocodeTimer = setInterval(processGeocodeQueue, GEOCODE_RATE_MS);
  }

  async function processGeocodeQueue() {
    if (!geocodeQueue.length) {
      clearInterval(geocodeTimer);
      geocodeTimer = null;
      return;
    }
    const job = geocodeQueue.shift();
    try {
      const { key, query, onResult } = job;

      const cached = geoCache.get(key);
      if (cached && isFinite(cached.lat) && isFinite(cached.lng)) {
        onResult(cached.lat, cached.lng);
        return;
      }

      const url = new URL('https://nominatim.openstreetmap.org/search');
      url.searchParams.set('format', 'json');
      url.searchParams.set('q', query);
      url.searchParams.set('countrycodes', 'us');
      url.searchParams.set('addressdetails', '0');
      url.searchParams.set('limit', '1');
      url.searchParams.set('viewbox', `${GEOCODE_BOUNDS.minLon},${GEOCODE_BOUNDS.maxLat},${GEOCODE_BOUNDS.maxLon},${GEOCODE_BOUNDS.minLat}`);
      url.searchParams.set('bounded', '1');
      url.searchParams.set('accept-language', 'en');

      const res = await fetch(url.toString(), { headers: { 'Accept': 'application/json' }});
      if (!res.ok) throw new Error('HTTP '+res.status);
      const arr = await res.json();
      if (Array.isArray(arr) && arr.length) {
        const lat = Number(arr[0].lat), lng = Number(arr[0].lon);
        if (isFinite(lat) && isFinite(lng)) {
          geoCache.set(key, lat, lng);
          onResult(lat, lng);
          return;
        }
      }
      onResult(null, null);
    } catch (e) {
      console.warn('Geocode failed:', e);
      job.onResult(null, null);
    }
  }

  function maybeGeocodeAndDropPin_Normal(a, id) {
    if (typeof a.lat === 'number' && typeof a.lng === 'number') return;
    const entry = live.get(id);
    if (!entry) return;
    if ((entry.expiresAt - Date.now()) < 30000) return;
    const addr = `${a.location || ''}${a.city ? ', '+a.city : ''}, NY`.trim();
    if (!addr || addr === ', NY') return;
    const cacheKey = addr.toLowerCase();
    enqueueGeocode(cacheKey, addr, (lat, lng) => {
      if (lat == null || lng == null) return;
      const curr = live.get(id);
      if (!curr || curr.expiresAt <= Date.now()) return;
      const color = colorFor(a);
      const marker = makeMarker(lat, lng, color, a);
      curr.marker = marker;
    });
  }

  function maybeGeocodeAndDropPin_Critical(a, id) {
    const entry = critLive.get(id);
    if (!entry) return;
    if ((entry.expiresAt - Date.now()) < 30000) return;
    const addr = `${a.location || ''}${a.city ? ', '+a.city : ''}, NY`.trim();
    if (!addr || addr === ', NY') return;
    const cacheKey = 'crit:'+addr.toLowerCase();
    enqueueGeocode(cacheKey, addr, (lat, lng) => {
      if (lat == null || lng == null) return;
      const curr = critLive.get(id);
      if (!curr || curr.expiresAt <= Date.now()) return;
      const marker = makeFireMarker(lat, lng, a);
      curr.marker = marker;
    });
  }
// ===== Bulletin: local (browser) storage =====
const BULLETIN_KEY = 'bulletin_text_v1';
const bulletinEl = document.getElementById('bulletin');
const saveBtn    = document.getElementById('bulletinSave');
const revertBtn  = document.getElementById('bulletinRevert');
const clearBtn   = document.getElementById('bulletinClear');
const statusEl   = document.getElementById('bulletinStatus');

let bulletinDirty = false;

function bulletinLoad() {
  try {
    const saved = localStorage.getItem(BULLETIN_KEY);
    if (saved) bulletinEl.innerHTML = saved;
  } catch {}
  statusEl.textContent = '';
}

function bulletinSave() {
  try {
    localStorage.setItem(BULLETIN_KEY, bulletinEl.innerHTML);
    bulletinDirty = false;
    const t = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false});
    statusEl.textContent = `Saved ${t}`;
    setTimeout(() => (statusEl.textContent = ''), 3000);
  } catch (e) {
    statusEl.textContent = 'Save failed';
  }
}

function bulletinClear() {
  if (!confirm('Clear bulletin and remove saved copy?')) return;
  bulletinEl.innerHTML = '';
  try { localStorage.removeItem(BULLETIN_KEY); } catch {}
  statusEl.textContent = 'Cleared';
  setTimeout(() => (statusEl.textContent = ''), 2000);
}

function bulletinRevert() {
  bulletinLoad();
}

// Events
bulletinEl.addEventListener('input', () => { bulletinDirty = true; });

// Buttons
saveBtn.addEventListener('click', bulletinSave);
revertBtn.addEventListener('click', bulletinRevert);
clearBtn.addEventListener('click', bulletinClear);

// Auto-save every 10s if changed
setInterval(() => { if (bulletinDirty) bulletinSave(); }, 10000);

// Cmd/Ctrl+S to save
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
    e.preventDefault();
    bulletinSave();
  }
});

// Load any saved content on page load
bulletinLoad();

  /* ===== Start both pollers ===== */
  function init() {
    startPolling();                   // normal feed
    setInterval(tickCritical, 15000); // critical feed every 15s
    tickCritical();
  }
  init();
</script>
</body>
</html>

