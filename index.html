<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nassau Alerts Command Center</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
  body { margin: 0; font-family: Arial, sans-serif; background: #111; color: #fff; display: flex; flex-direction: column; min-height: 100vh; }

  /* HEADER */
  header { display: flex; justify-content: space-between; align-items: center; background: #222; padding: 10px 20px; position: sticky; top: 0; z-index: 1000; font-weight: bold; flex-wrap: wrap; gap: 8px; }
  header div { min-width: 150px; text-align: center; }
  .header-actions button { background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:6px 10px;cursor:pointer; }

  /* CRITICAL BAR */
  .critical-wrap { overflow: hidden; background: #4a0000; height: 30px; position: sticky; top: 50px; z-index: 9999; border-bottom: 1px solid #660000; }
  .critical { display: flex; align-items: center; justify-content: center; gap: 18px; padding: 0 12px; color: #fff; line-height: 30px; font-weight: 700; letter-spacing: 0.2px; }
  .critical .chip { display: inline-flex; align-items: center; gap: 8px; background: #220000; padding: 3px 10px; border-radius: 999px; border: 1px solid #660000; }
  @keyframes critFlash { 0% { filter: brightness(1); } 50% { filter: brightness(2.2); } 100% { filter: brightness(1); } }
  .critical.flash-twice { animation: critFlash 0.6s ease-in-out 2; }

  /* TICKER */
  .ticker-wrap { overflow: hidden; background: #333; height: 30px; position: sticky; top: 80px; z-index: 999; }
  .ticker { display: inline-block; white-space: nowrap; padding-left: 100%; animation: scroll 45s linear infinite; color: #ffcc00; line-height: 30px; }
  @keyframes scroll { 0% { transform: translateX(0%); } 100% { transform: translateX(-100%); } }

  /* MAIN GRID — locked proportions: top row 2/3, bottom row 1/3 */
  main {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: 2fr 1fr;
    gap: 10px;
    padding: 10px;
    height: calc(100vh - 110px); /* header(50)+critical(30)+ticker(30) */
    min-height: 0;
  }

  /* Cards & content sizing */
  .card { display: flex; flex-direction: column; min-height: 0; min-width: 0; }
  .card h2 { flex: 0 0 auto; margin: 0; padding: 6px 8px; border-bottom: 1px solid #333; }
  .card > iframe,
  .card .bulletin-body,
  #alertMap { flex: 1 1 auto; min-height: 0; width: 100%; }
  .card > iframe { border: none; }

  /* Bulletin look + WRAPPING (no grid stretch) */
 .bulletin-body {
  overflow: auto;
  padding: 8px 10px;
  background: #1a1a1a;
  border-radius: 8px;
  line-height: 1.35;

  /* Wrapping so nothing stretches the grid */
  white-space: pre-wrap;        /* keep your line breaks, wrap long lines */
  overflow-wrap: anywhere;      /* break very long words/URLs */
  word-break: break-word;       /* extra safety for long tokens */
  max-width: 100%;
}
.bulletin-body a {
  color: #ffcc00;
  text-decoration: underline;
  word-break: break-word;       /* wrap long link text too */
}

  /* Map icon (SVG) for criticals */
  .leaflet-div-icon.crit-icon { background: transparent; border: none; }
  .crit-icon svg { width: 28px; height: 34px; display: block; filter: drop-shadow(0 0 2px #000); }

  /* RESPONSIVE */
  @media (max-width: 1024px) {
    main { grid-template-columns: repeat(2, 1fr); grid-template-rows: 2fr 1fr 1fr; }
    .bulletin-card, .map-card, .bulletin-read-card { grid-column: span 2; }
  }
  @media (max-width: 600px) {
    main { grid-template-columns: 1fr; grid-template-rows: repeat(6, minmax(0, 1fr)); }
    .card { grid-column: span 1; }
  }

  /* Edit mode visuals (temporary only; no persistence) */
  body.edit-mode .card { outline: 1px dashed #555; cursor: grab; }
  body.edit-mode .card:active { cursor: grabbing; }
  .card.dragging { opacity: 0.6; outline: 2px dashed #888; }

  /* Fullscreen overlay */
  body.fs-open { overflow: hidden; }
  #fsBackdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 10000; }
  .card.is-fullscreen {
    position: fixed; inset: 10px; z-index: 10001; margin: 0;
    max-width: none; max-height: none; width: auto; height: calc(100vh - 20px);
    border: 1px solid #333; box-shadow: 0 10px 30px rgba(0,0,0,0.6); background: #1a1a1a;
  }

  /* Clickable titles for fullscreen */
  .click-fs { cursor: pointer; }
</style>
</head>
<body>

<header>
  <div id="est-time">EST: --:--:--</div>
  <div>Nassau Alerts</div>
  <div id="zulu-time">Zulu: --:--:--</div>
  <div class="header-actions">
    <button id="editLayoutBtn">Edit layout</button>
    <button id="resetLayoutBtn" style="display:none;">Reset</button>
  </div>
</header>

<div class="critical-wrap">
  <div class="critical" id="criticalBar">No critical alerts.</div>
</div>

<div class="ticker-wrap">
  <div class="ticker" id="ticker">Loading alerts...</div>
</div>

<main>
  <div class="card" data-card-id="radar">
    <h2 class="click-fs">Radar (NWS)</h2>
    <iframe src="https://radar.weather.gov/ridge/standard/NORTHEAST_loop.gif"></iframe>
  </div>

  <div class="card" data-card-id="smoke">
    <h2 class="click-fs">Fire & Smoke Map (NWS)</h2>
    <iframe src="https://radar.weather.gov/"></iframe>
  </div>

  <div class="card" data-card-id="wildfire">
    <h2 class="click-fs">NY Wildfire Tracker</h2>
    <iframe src="https://www.mapofire.com/state/new-york"></iframe>
  </div>

  <!-- Editable Note Pad (left of the map) -->
  <div class="card bulletin-card" data-card-id="note-pad">
    <h2 class="click-fs">Note Pad</h2>
    <div class="bulletin-toolbar" style="display:inline-flex;gap:8px;align-items:center;font-weight:normal;padding:6px 8px 0;">
      <button id="bulletinSave"   style="background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:4px 8px;cursor:pointer;">Save</button>
      <button id="bulletinRevert" style="background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:4px 8px;cursor:pointer;">Revert</button>
      <button id="bulletinClear"  style="background:#552222;color:#fff;border:1px solid #774444;border-radius:6px;padding:4px 8px;cursor:pointer;">Clear</button>
      <button id="bulletinLink"   style="background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:4px 8px;cursor:pointer;">Link</button>
      <span id="bulletinStatus" style="color:#aaa;font-size:12px;"></span>
    </div>
    <div id="bulletin" class="bulletin-body" contenteditable="true">
      Welcome to the Nassau Alerts Command Center.

      • This space is editable by you! Use it for notes, or reminders.
      • You can put links here: https://www.weather.gov/
      • Basic formatting is supported (line breaks, lists).

      Stay safe.
    </div>
  </div>

  <!-- Map (center) -->
  <div class="card map-card" data-card-id="map">
    <h2 class="click-fs">Alert Map</h2>
    <div id="alertMap"></div>
  </div>

  <!-- Independent, code-controlled board (right of the map) -->
  <div class="card bulletin-read-card" data-card-id="right-board">
    <h2 class="click-fs">Quick Links and Numbers</h2>
    <div id="bulletinRead" class="bulletin-body" aria-readonly="true">
  Fire-Com: (516) 573-9800
  Med-Com: (516) 572-6259
  LIRR/MTA: (718) 558-8204
  CHEM-TREC: (800) 424-9300
  Poison Control: (800) 222-1222

  Hospital Availability:
  <a href="https://docs.google.com/spreadsheets/d/1nJYeGR6hNn5gIzqTDmN7qvdqQzU7Z_vAmUCiq1XAjYE/edit?gid=0"
     target="_blank" rel="noopener noreferrer">
    Hospital Availability Sheet
  </a>
</div>

  </div>
</main>

<footer>
  The information displayed and broadcasted is publicly available. 
  The site owner does not own the information. 
  The BRYX feed is made possible with continued access, granted by local departments. 
  Email <a href="mailto:alertsnassau@gmail.com">alertsnassau@gmail.com</a> to add your department!
</footer>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  /* ===== GLOBAL CONFIG & HELPERS ===== */
  const TTL_MS = 15 * 60 * 1000;   // keep items for 15 minutes

  function parseTs(s) {
    if (!s) return NaN;
    const cleaned = String(s).trim().replace(/(\.\d{3})\d+$/, '$1');
    const isoGuess = cleaned.includes('T') ? cleaned : cleaned.replace(' ', 'T');
    const hasTZ = /[zZ]|[+\-]\d{2}:?\d{2}$/.test(isoGuess);
    const finalStr = hasTZ ? isoGuess : isoGuess + 'Z';
    const t = Date.parse(finalStr);
    return Number.isNaN(t) ? Date.parse(cleaned) : t;
  }
  const fmtTime = (v) => {
    const ms = typeof v === 'number' ? v : parseTs(v);
    return Number.isNaN(ms) ? '—'
      : new Date(ms).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
  };
  const cacheBusted = (url) => url + (url.includes('?') ? '&' : '?') + '_cb=' + Date.now();

  /* ===== CLOCKS ===== */
  function updateClocks() {
    const est = new Date().toLocaleString("en-US", { timeZone: "America/New_York", hour12: false });
    const zulu = new Date().toISOString().substring(11,19) + "Z";
    document.getElementById("est-time").textContent = "EST: " + est;
    document.getElementById("zulu-time").textContent = "Zulu: " + zulu;
  }
  setInterval(updateClocks, 1000);
  updateClocks();

  /* ===== MAP ===== */
  const map = L.map('alertMap').setView([40.7, -73.6], 10);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
  const markersLayer = L.layerGroup().addTo(map);

  const mapEl = document.getElementById('alertMap');
  requestAnimationFrame(() => map.invalidateSize());
  setTimeout(() => map.invalidateSize(), 250);
  map.on('load', () => map.invalidateSize());
  window.addEventListener('resize', () => map.invalidateSize());
  if ('ResizeObserver' in window) new ResizeObserver(() => map.invalidateSize()).observe(mapEl);

  // Critical alerts use a crisp SVG flame marker
  const fireIcon = L.divIcon({
    className: 'crit-icon leaflet-div-icon',
    html: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <defs>
          <linearGradient id="flameGrad" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#FFA726"/>
            <stop offset="60%" stop-color="#FB8C00"/>
            <stop offset="100%" stop-color="#E53935"/>
          </linearGradient>
        </defs>
        <path fill="url(#flameGrad)" d="M32 4c8 10-4 16-4 26 0 8 8 12 8 20 0 8-6 14-14 14-10 0-18-8-18-20 0-12 10-18 16-26 6-8 4-12 12-14z"/>
        <path fill="#FFE082" d="M26 40c4 4 2 8 0 10-2 2-6 2-8-2-2-4 2-8 8-8z"/>
        <circle cx="41" cy="15" r="3" fill="#FFCC80"/>
      </svg>
    `,
    iconSize: [28, 34],
    iconAnchor: [14, 17]
  });

  /* ===== FEED ENDPOINTS ===== */
  const BASE_URL = 'https://script.google.com/macros/s/AKfycbwPPoh1MIUqw-D9DQh6CCk5cL001YUkKLYgL9QCPITBG7dLs3hVGqBR0XzqfQoKVgN8/exec';
  const ALERTS_URL = `${BASE_URL}?limit=100`;
  const CRIT_URL   = `${BASE_URL}?channel=critical&limit=40`;
  const POLL_MS = 20000;

  /* ===== NORMAL FEED (ticker + map) ===== */
  const live = new Map(); // id -> { marker, expiresAt, tickerSpan }
  const tickerEl = document.getElementById('ticker');

  function colorFor(a) {
    const cat = (a.category||'').toLowerCase();
    const call = (a.callType||'').toLowerCase();
    if (cat.includes('fire') || call.includes('fire')) return 'red';
    if (cat.includes('ems') || call.includes('ambulance')) return 'blue';
    return 'yellow';
  }
  function makeTickerSpan(a, color) {
    const dot = document.createElement('span');
    dot.style.cssText = 'display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;background:'+color;
    const text = document.createElement('span');
    text.textContent = `${(a.category||'').toUpperCase()} • ${a.location||''}${a.city? ', '+a.city:''} • ${fmtTime(a.eventTimestamp)}`;
    const wrap = document.createElement('span');
    wrap.style.marginRight = '40px';
    wrap.append(dot, text);
    return wrap;
  }
  function makeMarker(lat, lng, color, a) {
    return L.circleMarker([lat, lng], {
      radius: 8, color, weight: 2, fillColor: color, fillOpacity: 0.85
    }).bindTooltip(
      `${(a.category||'').toUpperCase()}<br>${a.location||''}${a.city? ', '+a.city:''}<br>${fmtTime(a.eventTimestamp)}`,
      {direction:'top', offset:[0,-8]}
    ).addTo(markersLayer);
  }
  function makeFireMarker(lat, lng, a) {
    const line1 = [(a.category || 'CRITICAL').toUpperCase(), (a.callType || '').toString().trim()].filter(Boolean).join(' • ');
    const line2 = [a.location || '', a.city || '', a.state || 'NY'].filter(Boolean).join(', ');
    const line3 = fmtTime(a.eventTimestamp);
    return L.marker([lat, lng], { icon: fireIcon })
      .bindTooltip(`${line1}<br>${line2}<br>${line3}`, { direction: 'top', offset: [0, -8] })
      .addTo(markersLayer);
  }
  function cleanupExpired() {
    const now = Date.now();
    for (const [id, obj] of live) {
      if (obj.expiresAt <= now) {
        if (obj.marker && map.hasLayer(obj.marker)) map.removeLayer(obj.marker);
        obj.tickerSpan?.remove();
        live.delete(id);
      }
    }
    if (live.size === 0 && !tickerEl.dataset.placeholderShown) {
      tickerEl.textContent = 'No recent alerts.';
      tickerEl.dataset.placeholderShown = '1';
    }
  }

  async function fetchAlertsOnce() {
    const res = await fetch(cacheBusted(ALERTS_URL), { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const json = await res.json();
    return (json.results || []).map(r => ({
      id: r.uniqueKey || `${r.incidentId || ''}-${r.eventTimestamp || ''}`,
      category: r.category,
      callType: r.callType,
      location: r.location,
      city: r.city,
      state: r.state || 'NY',
      eventTimestamp: r.eventTimestamp,
      lat: r.lat != null ? Number(r.lat) : null,
      lng: r.lng != null ? Number(r.lng) : null
    })).filter(x => !Number.isNaN(parseTs(x.eventTimestamp)));
  }

  let timer = null, cleanupTimer = null;

  async function tick() {
    try {
      const alerts = await fetchAlertsOnce();
      alerts.sort((a,b)=> parseTs(b.eventTimestamp) - parseTs(a.eventTimestamp));
      tickerEl.dataset.placeholderShown = '';

      const now = Date.now();
      for (const a of alerts) {
        const id = a.id;
        const tsMs = parseTs(a.eventTimestamp);
        const exp = Math.max(now, (Number.isNaN(tsMs) ? now : tsMs) + TTL_MS);

        if (live.has(id)) {
          live.get(id).expiresAt = Math.max(live.get(id).expiresAt, exp);
          continue;
        }

        const color = colorFor(a);
        const chip  = makeTickerSpan(a, color);
        tickerEl.insertBefore(chip, tickerEl.firstChild);

        let marker = null;
        if (typeof a.lat === 'number' && typeof a.lng === 'number' && isFinite(a.lat) && isFinite(a.lng)) {
          marker = makeMarker(a.lat, a.lng, color, a);
        }

        live.set(id, { marker, tickerSpan: chip, expiresAt: exp });

        if (marker == null) maybeGeocodeAndDropPin_Normal(a, id);
      }

      cleanupExpired();
    } catch (err) {
      console.error('BRYX fetch failed:', err);
    }
  }

  function startPolling() {
    if (timer) return;
    tick();
    timer = setInterval(tick, POLL_MS);
    if (!cleanupTimer) cleanupTimer = setInterval(cleanupExpired, 10000);
  }
  function stopPolling() { clearInterval(timer); timer = null; }
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') startPolling();
    else stopPolling();
  });

  /* ===== CRITICAL FEED (title bar with beep/flash + fire pins) ===== */
  function beep(times = 2, durationMs = 140, gapMs = 120, freq = 880) {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      let when = ctx.currentTime;
      for (let i = 0; i < times; i++) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.001, when);
        gain.gain.exponentialRampToValueAtTime(0.3, when + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, when + durationMs/1000);
        osc.connect(gain).connect(ctx.destination);
        osc.start(when);
        osc.stop(when + durationMs/1000);
        when += (durationMs + gapMs)/1000;
      }
      setTimeout(() => ctx.close(), (times*(durationMs+gapMs))+200);
    } catch {}
  }

  const criticalBar = document.getElementById('criticalBar');
  const critLive = new Map(); // id -> { el, marker, expiresAt }

  function makeCritChip(a) {
    const dot = document.createElement('span');
    dot.style.cssText = 'display:inline-block;width:10px;height:10px;border-radius:50%;background:#ff3b3b;';
    const txt = document.createElement('span');

    // Prefer callType; fall back to UPPERCASE category
    const title = (a.callType && String(a.callType).trim())
      || ((a.category ? String(a.category).toUpperCase() : 'CRITICAL'));

    const addr = [a.location || '', a.city || '', a.state || 'NY'].filter(Boolean).join(', ');
    const time = fmtTime(a.eventTimestamp);

    txt.textContent = `${title} - ${addr} - ${time}`;

    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.append(dot, txt);
    return chip;
  }

  async function fetchCriticalOnce() {
    const res = await fetch(cacheBusted(CRIT_URL), { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP '+res.status);
    const json = await res.json();

    const items = (json.results || []).map(r => {
      const eventTimestamp = r.eventTimestamp || r.timestamp || r.time || r.receivedAt || r.createdAt || new Date().toISOString();
      const callType = r.callType ?? r.type ?? r.title ?? r.event ?? r.call ?? r.description ?? r.details ?? '';
      return {
        id: r.uniqueKey || r.id || `${eventTimestamp || ''}-${r.location || ''}`,
        category: r.category || 'CRITICAL',
        callType: (callType != null ? String(callType) : ''),
        location: r.location || r.address || r.addr || '',
        city: r.city || '',
        state: r.state || 'NY',
        eventTimestamp,
        lat: (r.lat != null ? Number(r.lat) : (r.latitude != null ? Number(r.latitude) : null)),
        lng: (r.lng != null ? Number(r.lng) : (r.lon != null ? Number(r.lon) : (r.longitude != null ? Number(r.longitude) : null)))
      };
    }).filter(x => x.eventTimestamp);

    return items;
  }

  function cleanupCritical() {
    const now = Date.now();
    for (const [id, obj] of critLive) {
      if (obj.expiresAt <= now) {
        obj.el?.remove();
        if (obj.marker && map.hasLayer(obj.marker)) map.removeLayer(obj.marker);
        critLive.delete(id);
      }
    }
    if (critLive.size === 0) criticalBar.textContent = 'No critical alerts.';
  }

  async function tickCritical() {
    try {
      const items = await fetchCriticalOnce();
      items.sort((a,b) => parseTs(b.eventTimestamp) - parseTs(a.eventTimestamp));

      let introduced = 0;
      const now = Date.now();

      for (const a of items) {
        const id = a.id;
        const tsMs = parseTs(a.eventTimestamp);
        const exp = Math.max(now, (Number.isNaN(tsMs) ? now : tsMs) + TTL_MS);

        if (critLive.has(id)) {
          critLive.get(id).expiresAt = Math.max(critLive.get(id).expiresAt, exp);
          continue;
        }
        if (criticalBar.textContent === 'No critical alerts.') criticalBar.textContent = '';

        const chip = makeCritChip(a);
        criticalBar.insertBefore(chip, criticalBar.firstChild);

        let marker = null;
        if (typeof a.lat === 'number' && typeof a.lng === 'number' && isFinite(a.lat) && isFinite(a.lng)) {
          marker = makeFireMarker(a.lat, a.lng, a);
        }

        critLive.set(id, { el: chip, marker, expiresAt: exp });

        if (marker == null) maybeGeocodeAndDropPin_Critical(a, id);
        introduced++;
      }

      if (introduced > 0) {
        criticalBar.classList.remove('flash-twice'); void criticalBar.offsetWidth;
        criticalBar.classList.add('flash-twice');
        beep(2, 140, 120, 988);
        criticalBar.addEventListener('animationend', () => criticalBar.classList.remove('flash-twice'), { once: true });
      }

      cleanupCritical();
    } catch (e) {
      console.error('Critical fetch failed:', e);
    }
  }

  /* ===== Geocoding ===== */
  const GEOCODE_RATE_MS = 1200;
  const GEOCODE_TTL_MS  = 7 * 24 * 60 * 60 * 1000;
  const GEOCODE_BOUNDS  = { minLon: -73.90, minLat: 40.50, maxLon: -73.40, maxLat: 40.90 };

  const geoCache = {
    get(key) { try { const raw = localStorage.getItem('geo_'+key); if (!raw) return null; const obj = JSON.parse(raw); if (!obj || (obj.t && (Date.now()-obj.t) > GEOCODE_TTL_MS)) return null; return obj; } catch { return null; } },
    set(key, lat, lng) { try { localStorage.setItem('geo_'+key, JSON.stringify({lat,lng,t:Date.now()})); } catch {} }
  };

  const geocodeQueue = [];
  let geocodeTimer = null;

  function enqueueGeocode(key, query, onResult) {
    if (geocodeQueue.find(q => q.key === key)) return;
    geocodeQueue.push({ key, query, onResult });
    if (!geocodeTimer) geocodeTimer = setInterval(processGeocodeQueue, GEOCODE_RATE_MS);
  }

  async function processGeocodeQueue() {
    if (!geocodeQueue.length) { clearInterval(geocodeTimer); geocodeTimer = null; return; }
    const job = geocodeQueue.shift();
    try {
      const { key, query, onResult } = job;

      const cached = geoCache.get(key);
      if (cached && isFinite(cached.lat) && isFinite(cached.lng)) { onResult(cached.lat, cached.lng); return; }

      const url = new URL('https://nominatim.openstreetmap.org/search');
      url.searchParams.set('format', 'json');
      url.searchParams.set('q', query);
      url.searchParams.set('countrycodes', 'us');
      url.searchParams.set('addressdetails', '0');
      url.searchParams.set('limit', '1');
      url.searchParams.set('viewbox', `${GEOCODE_BOUNDS.minLon},${GEOCODE_BOUNDS.maxLat},${GEOCODE_BOUNDS.maxLon},${GEOCODE_BOUNDS.minLat}`);
      url.searchParams.set('bounded', '1');
      url.searchParams.set('accept-language', 'en');

      const res = await fetch(url.toString(), { headers: { 'Accept': 'application/json' }});
      if (!res.ok) throw new Error('HTTP '+res.status);
      const arr = await res.json();
      if (Array.isArray(arr) && arr.length) {
        const lat = Number(arr[0].lat), lng = Number(arr[0].lon);
        if (isFinite(lat) && isFinite(lng)) { geoCache.set(key, lat, lng); onResult(lat, lng); return; }
      }
      onResult(null, null);
    } catch (e) {
      console.warn('Geocode failed:', e);
      job.onResult(null, null);
    }
  }

  function maybeGeocodeAndDropPin_Normal(a, id) {
    if (typeof a.lat === 'number' && typeof a.lng === 'number') return;
    const entry = live.get(id); if (!entry) return;
    if ((entry.expiresAt - Date.now()) < 30000) return;
    const addrParts = [a.location || '', a.city || '', a.state || 'NY'].filter(Boolean).join(', ');
    if (!a.location) return;
    const cacheKey = addrParts.toLowerCase();
    enqueueGeocode(cacheKey, addrParts, (lat, lng) => {
      if (lat == null || lng == null) return;
      const curr = live.get(id); if (!curr || curr.expiresAt <= Date.now()) return;
      const color = colorFor(a);
      curr.marker = makeMarker(lat, lng, color, a);
    });
  }

  function maybeGeocodeAndDropPin_Critical(a, id) {
    const entry = critLive.get(id); if (!entry) return;
    if ((entry.expiresAt - Date.now()) < 30000) return;
    const addr = [a.location || '', a.city || '', a.state || 'NY'].filter(Boolean).join(', ');
    if (!a.location) return;
    const cacheKey = 'crit:' + addr.toLowerCase();
    enqueueGeocode(cacheKey, addr, (lat, lng) => {
      if (lat == null || lng == null) return;
      const curr = critLive.get(id); if (!curr || curr.expiresAt <= Date.now()) return;
      curr.marker = makeFireMarker(lat, lng, a);
    });
  }

  /* ===== LINKIFY (auto-turn URLs into <a> tags) ===== */
  function linkifyElement(el) {
    if (!el) return;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
    const urlRe = /\bhttps?:\/\/[^\s<>"')]+/gi;
    const textNodes = [];
    let n;
    while ((n = walker.nextNode())) {
      // Skip text already inside an anchor
      if (n.parentNode && n.parentNode.closest('a')) continue;
      textNodes.push(n);
    }
    textNodes.forEach(node => {
      const txt = node.nodeValue;
      if (!urlRe.test(txt)) return;

      const frag = document.createDocumentFragment();
      let last = 0;
      txt.replace(urlRe, (match, offset) => {
        if (offset > last) frag.appendChild(document.createTextNode(txt.slice(last, offset)));
        const a = document.createElement('a');
        a.href = match;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.textContent = match;
        frag.appendChild(a);
        last = offset + match.length;
      });
      if (last < txt.length) frag.appendChild(document.createTextNode(txt.slice(last)));
      node.parentNode.replaceChild(frag, node);
    });
  }

  // Ensure any <a> inside these panes opens in a new tab (also solves contenteditable click)
  function ensureAnchorTargets(el) {
    if (!el) return;
    el.querySelectorAll('a').forEach(a => {
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
    });
  }

  /* ===== Left Note Pad (user-editable) ===== */
  const BULLETIN_KEY = 'bulletin_text_v1';
  const bulletinEl   = document.getElementById('bulletin');
  const saveBtn      = document.getElementById('bulletinSave');
  const revertBtn    = document.getElementById('bulletinRevert');
  const clearBtn     = document.getElementById('bulletinClear');
  const linkBtn      = document.getElementById('bulletinLink');
  const statusEl     = document.getElementById('bulletinStatus');

  let bulletinDirty = false;

  function bulletinLoad() {
    try {
      const saved = localStorage.getItem(BULLETIN_KEY);
      if (saved) bulletinEl.innerHTML = saved;
    } catch {}
    // Make pasted/typed URLs clickable after load
    linkifyElement(bulletinEl);
    ensureAnchorTargets(bulletinEl);
    statusEl.textContent = '';
  }

  function bulletinSave() {
    try {
      // Normalize links before save
      linkifyElement(bulletinEl);
      ensureAnchorTargets(bulletinEl);
      localStorage.setItem(BULLETIN_KEY, bulletinEl.innerHTML);
      bulletinDirty = false;
      const t = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false});
      statusEl.textContent = `Saved ${t}`;
      setTimeout(() => (statusEl.textContent = ''), 3000);
    } catch {
      statusEl.textContent = 'Save failed';
    }
  }

  function bulletinClear() {
    if (!confirm('Clear bulletin and remove saved copy?')) return;
    bulletinEl.innerHTML = '';
    try { localStorage.removeItem(BULLETIN_KEY); } catch {}
    statusEl.textContent = 'Cleared';
    setTimeout(() => (statusEl.textContent = ''), 2000);
  }
  function bulletinRevert() { bulletinLoad(); }

  bulletinEl.addEventListener('input', () => { bulletinDirty = true; });

  // Make links clickable even inside contenteditable
  bulletinEl.addEventListener('click', (e) => {
    const a = e.target.closest('a');
    if (a) {
      e.preventDefault();
      window.open(a.href, '_blank', 'noopener');
    }
  });

  // Link button (optional): create/wrap selection as link
  if (linkBtn) {
    linkBtn.addEventListener('click', () => {
      const sel = window.getSelection();
      const defaultUrl = 'https://';
      const url = prompt('Enter URL (https://...)', defaultUrl);
      if (!url || url === 'https://') return;
      const safe = /^https?:\/\//i.test(url) ? url : 'https://' + url;

      // Insert or wrap selection
      document.execCommand('createLink', false, safe);
      // Ensure target/rel on created links
      ensureAnchorTargets(bulletinEl);
      bulletinDirty = true;
      // Also turn any bare URLs nearby into anchors
      linkifyElement(bulletinEl);
    });
  }

  if (saveBtn)   saveBtn.addEventListener('click', bulletinSave);
  if (revertBtn) revertBtn.addEventListener('click', bulletinRevert);
  if (clearBtn)  clearBtn.addEventListener('click', bulletinClear);

  setInterval(() => { if (bulletinDirty) bulletinSave(); }, 10000);
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
      e.preventDefault(); bulletinSave();
    }
  });

  /* ===== Right Board (code-controlled only) ===== */
  const BULLETIN_READ_KEY = 'bulletin_read_text_v1';
  const readEl = document.getElementById('bulletinRead');
  function readBoardLoad() {
    try {
      const saved = localStorage.getItem(BULLETIN_READ_KEY);
      if (saved) readEl.innerHTML = saved;
    } catch {}
    // Linkify & wrap
    linkifyElement(readEl);
    ensureAnchorTargets(readEl);
  }
  function setReadBoard(html) {
    try {
      localStorage.setItem(BULLETIN_READ_KEY, html);
      readEl.innerHTML = html;
      linkifyElement(readEl);
      ensureAnchorTargets(readEl);
    } catch {}
  }
  window.setReadBoard = setReadBoard;

  /* ===== TEMP LAYOUT DRAG (no persistence) ===== */
  const mainEl = document.querySelector('main');
  const editBtn = document.getElementById('editLayoutBtn');
  const resetBtn = document.getElementById('resetLayoutBtn');
  let editOn = false;
  let dragSrcEl = null;

  function setEditMode(on) {
    document.body.classList.toggle('edit-mode', on);
    Array.from(mainEl.children).forEach(card => { if (card.classList.contains('card')) card.draggable = !!on; });
    resetBtn.style.display = on ? 'inline-block' : 'none';
    if (!on && typeof map?.invalidateSize === 'function') setTimeout(() => map.invalidateSize(), 50);
  }
  function handleDragStart(e) { const card = e.currentTarget; dragSrcEl = card; card.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; e.dataTransfer.setData('text/plain', card.dataset.cardId || ''); }
  function handleDragEnd(e) { e.currentTarget.classList.remove('dragging'); dragSrcEl = null; if (typeof map?.invalidateSize === 'function') setTimeout(() => map.invalidateSize(), 50); }
  function handleDragOver(e) { if (!editOn) return; e.preventDefault(); const target = e.target.closest('.card'); if (!target || target === dragSrcEl) return; const rect = target.getBoundingClientRect(); const before = (e.clientY - rect.top) < rect.height/2; if (before) mainEl.insertBefore(dragSrcEl, target); else mainEl.insertBefore(dragSrcEl, target.nextSibling); }
  function initDragAndDrop() { mainEl.addEventListener('dragover', handleDragOver); Array.from(mainEl.children).forEach(card => { if (!card.classList.contains('card')) return; card.addEventListener('dragstart', handleDragStart); card.addEventListener('dragend', handleDragEnd); }); }
  if (editBtn) editBtn.addEventListener('click', () => { editOn = !editOn; editBtn.textContent = editOn ? 'Done' : 'Edit layout'; setEditMode(editOn); if (editOn) initDragAndDrop(); });
  if (resetBtn) resetBtn.addEventListener('click', () => { location.reload(); });

  /* ===== Fullscreen (all cards) ===== */
  let fsCard = null, fsBackdrop = null;
  function enterFullscreen(card) {
    if (fsCard) exitFullscreen();
    fsBackdrop = document.createElement('div'); fsBackdrop.id = 'fsBackdrop'; document.body.appendChild(fsBackdrop);
    document.body.classList.add('fs-open'); card.classList.add('is-fullscreen'); fsCard = card;
    fsBackdrop.addEventListener('click', exitFullscreen, { once: true });
    document.addEventListener('keydown', escListener);
    if (card.contains(mapEl) && typeof map?.invalidateSize === 'function') setTimeout(() => map.invalidateSize(), 80);
  }
  function escListener(e) { if (e.key === 'Escape') exitFullscreen(); }
  function exitFullscreen() {
    if (!fsCard) return;
    fsCard.classList.remove('is-fullscreen');
    if (fsBackdrop && fsBackdrop.parentNode) fsBackdrop.parentNode.removeChild(fsBackdrop);
    fsBackdrop = null; document.body.classList.remove('fs-open'); document.removeEventListener('keydown', escListener);
    if (typeof map?.invalidateSize === 'function') setTimeout(() => map.invalidateSize(), 80);
    fsCard = null;
  }
  function toggleFS(card) { if (fsCard === card) exitFullscreen(); else enterFullscreen(card); }
  document.querySelectorAll('main .card > h2').forEach(h2 => { h2.classList.add('click-fs'); h2.addEventListener('click', () => { const card = h2.closest('.card'); if (!card) return; toggleFS(card); }); });

  /* ===== Start everything ===== */
  function init() {
    bulletinLoad();
    readBoardLoad();
    startPolling();
    setInterval(tickCritical, 15000);
    tickCritical();
  }
  init();
</script>
</body>
</html>
