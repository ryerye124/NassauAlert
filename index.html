<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nassau Alerts Command Center</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
  body { margin: 0; font-family: Arial, sans-serif; background: #111; color: #fff; display: flex; flex-direction: column; min-height: 100vh; }

  /* HEADER */
  header { display: flex; justify-content: space-between; align-items: center; background: #222; padding: 10px 20px; position: sticky; top: 0; z-index: 1000; font-weight: bold; flex-wrap: wrap; gap: 8px; }
  header div { min-width: 150px; text-align: center; }
  .header-actions button { background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:6px 10px;cursor:pointer; }

  /* CRITICAL BAR (between header and ticker) */
  .critical-wrap { overflow: hidden; background: #4a0000; height: 30px; position: sticky; top: 50px; z-index: 9999; border-bottom: 1px solid #660000; }
  .critical { display: flex; align-items: center; justify-content: center; gap: 18px; padding: 0 12px; color: #fff; line-height: 30px; font-weight: 700; letter-spacing: 0.2px; }
  .critical .chip { display: inline-flex; align-items: center; gap: 8px; background: #220000; padding: 3px 10px; border-radius: 999px; border: 1px solid #660000; }
  @keyframes critFlash { 0% { filter: brightness(1); } 50% { filter: brightness(2.2); } 100% { filter: brightness(1); } }
  .critical.flash-twice { animation: critFlash 0.6s ease-in-out 2; }

  /* TICKER */
  .ticker-wrap { overflow: hidden; background: #333; height: 30px; position: sticky; top: 80px; z-index: 999; }
  .ticker { display: inline-block; white-space: nowrap; padding-left: 100%; animation: scroll 45s linear infinite; color: #ffcc00; line-height: 30px; }
  @keyframes scroll { 0% { transform: translateX(0%); } 100% { transform: translateX(-100%); } }

  /* MAIN GRID — locked proportions: top row 2/3, bottom row 1/3 */
  main {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: 2fr 1fr;      /* <- 2:1 height split */
    gap: 10px;
    padding: 10px;
    height: calc(100vh - 110px);      /* header(50) + critical(30) + ticker(30) */
  }

  /* Make embedded content fill their grid cells nicely */
  .card { display: flex; flex-direction: column; min-height: 0; }
  .card h2 { flex: 0 0 auto; margin: 0; padding: 6px 8px; border-bottom: 1px solid #333; }

  /* Content fillers */
  .card > iframe,
  .card .bulletin-body,
  #alertMap {
    flex: 1 1 auto;
    min-height: 0;         /* needed so inner scrollers work inside flex */
    width: 100%;
  }
  .card > iframe { border: none; }

  /* Bulletin look */
  .bulletin-body {
    overflow: auto;
    padding: 8px 10px;
    background: #1a1a1a;
    border-radius: 8px;
    line-height: 1.35;
    white-space: pre-line;
  }
  .bulletin-body a { color: #ffcc00; text-decoration: underline; }
  .bulletin-body ul { margin: 6px 0 6px 18px; }
  .bulletin-body p { margin: 6px 0; }

  /* Map icon (SVG) for criticals */
  .leaflet-div-icon.crit-icon { background: transparent; border: none; }
  .crit-icon svg { width: 28px; height: 34px; display: block; filter: drop-shadow(0 0 2px #000); }

  /* RESPONSIVE (class-based) */
  @media (max-width: 1024px) {
    main {
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: 2fr 1fr 1fr; /* top row still tallest */
    }
    .bulletin-card,
    .map-card,
    .bulletin-read-card { grid-column: span 2; }
  }
  @media (max-width: 600px) {
    main {
      grid-template-columns: 1fr;
      grid-template-rows: repeat(6, minmax(0, 1fr));
    }
    .card { grid-column: span 1; }
  }

  /* ===== Edit mode visuals (temporary only; no persistence) ===== */
  body.edit-mode .card { outline: 1px dashed #555; cursor: grab; }
  body.edit-mode .card:active { cursor: grabbing; }
  .card.dragging { opacity: 0.6; outline: 2px dashed #888; }

  /* ===== Fullscreen overlay ===== */
  body.fs-open { overflow: hidden; }
  #fsBackdrop {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 10000;
  }
  .card.is-fullscreen {
    position: fixed;
    inset: 10px;
    z-index: 10001;
    margin: 0;
    max-width: none;
    max-height: none;
    width: auto;
    height: calc(100vh - 20px);
    border: 1px solid #333;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    background: #1a1a1a;
  }
  /* Make the two titles look clickable for fullscreen */
  .click-fs { cursor: pointer; }
</style>
</head>
<body>

<header>
  <div id="est-time">EST: --:--:--</div>
  <div>Nassau Alerts</div>
  <div id="zulu-time">Zulu: --:--:--</div>
  <div class="header-actions">
    <button id="editLayoutBtn">Edit layout</button>
    <button id="resetLayoutBtn" style="display:none;">Reset</button>
  </div>
</header>

<div class="critical-wrap">
  <div class="critical" id="criticalBar">No critical alerts.</div>
</div>

<div class="ticker-wrap">
  <div class="ticker" id="ticker">Loading alerts...</div>
</div>

<main>
  <div class="card" data-card-id="radar">
    <h2>Radar (NWS)</h2>
    <iframe src="https://radar.weather.gov/ridge/standard/NORTHEAST_loop.gif"></iframe>
  </div>

  <div class="card" data-card-id="smoke">
    <h2>Fire & Smoke Map (NWS)</h2>
    <iframe src="https://radar.weather.gov/"></iframe>
  </div>

  <div class="card" data-card-id="wildfire">
    <h2>NY Wildfire Tracker</h2>
    <iframe src="https://www.mapofire.com/state/new-york"></iframe>
  </div>

  <!-- Editable Note Pad (left of the map) -->
  <div class="card bulletin-card" data-card-id="note-pad">
    <h2 id="notePadTitle" class="click-fs" title="Click to toggle fullscreen">Note Pad</h2>
    <div class="bulletin-toolbar" style="display:inline-flex;gap:8px;align-items:center;font-weight:normal;padding:6px 8px 0;">
      <button id="bulletinSave" style="background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:4px 8px;cursor:pointer;">Save</button>
      <button id="bulletinRevert" style="background:#333;color:#fff;border:1px solid #555;border-radius:6px;padding:4px 8px;cursor:pointer;">Revert</button>
      <button id="bulletinClear" style="background:#552222;color:#fff;border:1px solid #774444;border-radius:6px;padding:4px 8px;cursor:pointer;">Clear</button>
      <span id="bulletinStatus" style="color:#aaa;font-size:12px;"></span>
    </div>
    <div id="bulletin" class="bulletin-body" contenteditable="true">
      Welcome to the Nassau Alerts Command Center.

      • This space is editable by you! Use it for notes, or reminders.
      • You can put links here: https://www.weather.gov/
      • Basic formatting is supported (line breaks, lists).

      Stay safe.
    </div>
  </div>

  <!-- Map (center) -->
  <div class="card map-card" data-card-id="map">
    <h2 id="mapTitle" class="click-fs" title="Click to toggle fullscreen">Alert Map</h2>
    <div id="alertMap"></div>
  </div>

  <!-- Independent, code-controlled board (right of the map) -->
  <div class="card bulletin-read-card" data-card-id="right-board">
    <h2>Quick Links and Numbers</h2>
    <div id="bulletinRead" class="bulletin-body" aria-readonly="true">
      Fire-Com: (516) 573-9800
      Med-Com: (516) 572-6259
      LIRR/MTA: (718) 558-8204
      CHEM-TREC: (800) 424-9300
      Poison Control: (800) 222-1222
    </div>
  </div>
</main>

<footer>
  The information displayed and broadcasted is publicly available. 
  The site owner does not own the information. 
  The BRYX feed is made possible with continued access, granted by local departments. 
  Email <a href="mailto:alertsnassau@gmail.com">alertsnassau@gmail.com</a> to add your department!
</footer>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  /* ===== GLOBAL CONFIG & HELPERS ===== */
  const TTL_MS = 15 * 60 * 1000;   // keep items for 15 minutes

  function parseTs(s) {
    if (!s) return NaN;
    const cleaned = String(s).trim().replace(/(\.\d{3})\d+$/, '$1');
    const isoGuess = cleaned.includes('T') ? cleaned : cleaned.replace(' ', 'T');
    const hasTZ = /[zZ]|[+\-]\d{2}:?\d{2}$/.test(isoGuess);
    const finalStr = hasTZ ? isoGuess : isoGuess + 'Z';
    const t = Date.parse(finalStr);
    return Number.isNaN(t) ? Date.parse(cleaned) : t;
  }
  const fmtTime = (v) => {
    const ms = typeof v === 'number' ? v : parseTs(v);
    return Number.isNaN(ms)
      ? '—'
      : new Date(ms).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
  };
  function cacheBusted(url) {
    const sep = url.includes('?') ? '&' : '?';
    return `${url}${sep}_cb=${Date.now()}`;
  }

  /* ===== CLOCKS ===== */
  function updateClocks() {
    const est = new Date().toLocaleString("en-US", { timeZone: "America/New_York", hour12: false });
    const zulu = new Date().toISOString().substring(11,19) + "Z";
    document.getElementById("est-time").textContent = "EST: " + est;
    document.getElementById("zulu-time").textContent = "Zulu: " + zulu;
  }
  setInterval(updateClocks, 1000);
  updateClocks();

  /* ===== MAP ===== */
  const map = L.map('alertMap').setView([40.7, -73.6], 10);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
  const markersLayer = L.layerGroup().addTo(map);

  /* Help Safari/Firefox measure the map after layout settles */
  const mapEl = document.getElementById('alertMap');
  requestAnimationFrame(() => map.invalidateSize());
  setTimeout(() => map.invalidateSize(), 250);
  map.on('load', () => map.invalidateSize());
  window.addEventListener('resize', () => map.invalidateSize());
  if ('ResizeObserver' in window) {
    const ro = new ResizeObserver(() => map.invalidateSize());
    ro.observe(mapEl);
  }

  // Critical alerts use a crisp SVG flame marker
  const fireIcon = L.divIcon({
    className: 'crit-icon leaflet-div-icon',
    html: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <defs>
          <linearGradient id="flameGrad" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#FFA726"/>
            <stop offset="60%" stop-color="#FB8C00"/>
            <stop offset="100%" stop-color="#E53935"/>
          </linearGradient>
        </defs>
        <path fill="url(#flameGrad)" d="M32 4c8 10-4 16-4 26 0 8 8 12 8 20 0 8-6 14-14 14-10 0-18-8-18-20 0-12 10-18 16-26 6-8 4-12 12-14z"/>
        <path fill="#FFE082" d="M26 40c4 4 2 8 0 10-2 2-6 2-8-2-2-4 2-8 8-8z"/>
        <circle cx="41" cy="15" r="3" fill="#FFCC80"/>
      </svg>
    `,
    iconSize: [28, 34],
    iconAnchor: [14, 17]
  });

  /* ===== FEED ENDPOINTS ===== */
  const BASE_URL = 'https://script.google.com/macros/s/AKfycbwjKKxg6mqOkjyZnUq2p4g2osIpTUlPKjlUg4RXFpj2W6u48sLnxjUlf7nN9ws394Zp/exec';
  const ALERTS_URL = `${BASE_URL}?limit=100`;                    // normal
  const CRIT_URL   = `${BASE_URL}?channel=critical&limit=40`;   // critical
  const POLL_MS = 20000;

  /* ===== NORMAL FEED (ticker + map) ===== */
  const live = new Map(); // id -> { marker, expiresAt, tickerSpan }
  const tickerEl = document.getElementById('ticker');

  function colorFor(a) {
    const cat = (a.category||'').toLowerCase();
    const call = (a.callType||'').toLowerCase();
    if (cat.includes('fire') || call.includes('fire')) return 'red';
    if (cat.includes('ems') || call.includes('ambulance')) return 'blue';
    return 'yellow';
  }
  function makeTickerSpan(a, color) {
    const dot = document.createElement('span');
    dot.style.cssText = 'display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;background:'+color;
    const text = document.createElement('span');
    text.textContent = `${(a.category||'').toUpperCase()} • ${a.location||''}${a.city? ', '+a.city:''} • ${fmtTime(a.eventTimestamp)}`;
    const wrap = document.createElement('span');
    wrap.style.marginRight = '40px';
    wrap.append(dot, text);
    return wrap;
  }
  function makeMarker(lat, lng, color, a) {
    return L.circleMarker([lat, lng], {
      radius: 8, color, weight: 2, fillColor: color, fillOpacity: 0.85
    }).bindTooltip(
      `${(a.category||'').toUpperCase()}<br>${a.location||''}${a.city? ', '+a.city:''}<br>${fmtTime(a.eventTimestamp)}`,
      {direction:'top', offset:[0,-8]}
    ).addTo(markersLayer);
  }
  function makeFireMarker(lat, lng, a) {
    return L.marker([lat, lng], { icon: fireIcon })
      .bindTooltip(
        `${(a.category||'CRITICAL').toUpperCase()}<br>${a.location||''}${a.city? ', '+a.city:''}<br>${fmtTime(a.eventTimestamp)}`,
        { direction: 'top', offset: [0, -8] }
      )
      .addTo(markersLayer);
  }
  function cleanupExpired() {
    const now = Date.now();
    for (const [id, obj] of live) {
      if (obj.expiresAt <= now) {
        if (obj.marker && map.hasLayer(obj.marker)) map.removeLayer(obj.marker);
        obj.tickerSpan?.remove();
        live.delete(id);
      }
    }
    if (live.size === 0 && !tickerEl.dataset.placeholderShown) {
      tickerEl.textContent = 'No recent alerts.';
      tickerEl.dataset.placeholderShown = '1';
    }
  }

  async function fetchAlertsOnce() {
    const res = await fetch(cacheBusted(ALERTS_URL), { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const json = await res.json();
    return (json.results || []).map(r => ({
      id: r.uniqueKey || `${r.incidentId || ''}-${r.eventTimestamp || ''}`,
      category: r.category,
      callType: r.callType,
      location: r.location,
      city: r.city,
      eventTimestamp: r.eventTimestamp,
      lat: r.lat != null ? Number(r.lat) : null,
      lng: r.lng != null ? Number(r.lng) : null
    })).filter(x => !Number.isNaN(parseTs(x.eventTimestamp)));
  }

  let timer = null, cleanupTimer = null;

  async function tick() {
    try {
      const alerts = await fetchAlertsOnce();
      alerts.sort((a,b)=> parseTs(b.eventTimestamp) - parseTs(a.eventTimestamp));
      tickerEl.dataset.placeholderShown = '';

      const now = Date.now();
      for (const a of alerts) {
        const id = a.id;
        const tsMs = parseTs(a.eventTimestamp);
        const exp = Math.max(now, (Number.isNaN(tsMs) ? now : tsMs) + TTL_MS);

        if (live.has(id)) {
          live.get(id).expiresAt = Math.max(live.get(id).expiresAt, exp);
          continue;
        }

        const color = colorFor(a);
        const chip  = makeTickerSpan(a, color);
        tickerEl.insertBefore(chip, tickerEl.firstChild);

        let marker = null;
        if (typeof a.lat === 'number' && typeof a.lng === 'number' && isFinite(a.lat) && isFinite(a.lng)) {
          marker = makeMarker(a.lat, a.lng, color, a);
        }

        live.set(id, { marker, tickerSpan: chip, expiresAt: exp });

        // Geocode if missing coords (normal feed)
        if (marker == null) {
          maybeGeocodeAndDropPin_Normal(a, id);
        }
      }

      cleanupExpired();
    } catch (err) {
      console.error('BRYX fetch failed:', err);
    }
  }

  function startPolling() {
    if (timer) return;
    tick(); // immediate
    timer = setInterval(tick, POLL_MS);
    if (!cleanupTimer) cleanupTimer = setInterval(cleanupExpired, 10000);
  }
  function stopPolling() { clearInterval(timer); timer = null; }

  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') startPolling();
    else stopPolling();
  });

  /* ===== CRITICAL FEED (title bar with beep/flash + fire pins) ===== */
  function beep(times = 2, durationMs = 140, gapMs = 120, freq = 880) {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      let when = ctx.currentTime;
      for (let i = 0; i < times; i++) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.001, when);
        gain.gain.exponentialRampToValueAtTime(0.3, when + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, when + durationMs/1000);
        osc.connect(gain).connect(ctx.destination);
        osc.start(when);
        osc.stop(when + durationMs/1000);
        when += (durationMs + gapMs)/1000;
      }
      setTimeout(() => ctx.close(), (times*(durationMs+gapMs))+200);
    } catch {}
  }

  const criticalBar = document.getElementById('criticalBar');
  const critLive = new Map(); // id -> { el, marker, expiresAt }

  function makeCritChip(a) {
    const dot = document.createElement('span');
    dot.style.cssText = 'display:inline-block;width:10px;height:10px;border-radius:50%;background:#ff3b3b;';
    const txt = document.createElement('span');
    const parts = [
      (a.category || 'CRITICAL').toUpperCase(),
      (a.callType || '').trim(),
      `${a.location || ''}${a.city ? ', ' + a.city : ''}`,
      fmtTime(a.eventTimestamp)
    ].filter(Boolean);
    txt.textContent = parts.join(' • ');
    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.append(dot, txt);
    return chip;
  }

  async function fetchCriticalOnce() {
    const res = await fetch(cacheBusted(CRIT_URL), { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP '+res.status);
    const json = await res.json();
    return (json.results || []).map(r => ({
      id: r.uniqueKey || `${r.eventTimestamp||''}-${r.location||''}`,
      category: r.category,
      callType: r.callType,
      location: r.location,
      city: r.city,
      eventTimestamp: r.eventTimestamp,
      lat: r.lat != null ? Number(r.lat) : null,
      lng: r.lng != null ? Number(r.lng) : null
    })).filter(x => x.eventTimestamp);
  }

  function cleanupCritical() {
    const now = Date.now();
    for (const [id, obj] of critLive) {
      if (obj.expiresAt <= now) {
        obj.el?.remove();
        if (obj.marker && map.hasLayer(obj.marker)) map.removeLayer(obj.marker);
        critLive.delete(id);
      }
    }
    if (critLive.size === 0) {
      criticalBar.textContent = 'No critical alerts.';
    }
  }

  async function tickCritical() {
    try {
      const items = await fetchCriticalOnce();
      items.sort((a,b) => parseTs(b.eventTimestamp) - parseTs(a.eventTimestamp));

      let introduced = 0;
      const now = Date.now();

      for (const a of items) {
        const id = a.id;
        const tsMs = parseTs(a.eventTimestamp);
        const exp = Math.max(now, (Number.isNaN(tsMs) ? now : tsMs) + TTL_MS);
        if (critLive.has(id)) {
          critLive.get(id).expiresAt = Math.max(critLive.get(id).expiresAt, exp);
          continue;
        }
        if (criticalBar.textContent === 'No critical alerts.') criticalBar.textContent = '';

        const chip = makeCritChip(a);
        criticalBar.insertBefore(chip, criticalBar.firstChild);

        let marker = null;
        if (typeof a.lat === 'number' && typeof a.lng === 'number' && isFinite(a.lat) && isFinite(a.lng)) {
          marker = makeFireMarker(a.lat, a.lng, a);
        }

        critLive.set(id, { el: chip, marker, expiresAt: exp });

        // Geocode if missing coords (critical feed)
        if (marker == null) {
          maybeGeocodeAndDropPin_Critical(a, id);
        }

        introduced++;
      }

      if (introduced > 0) {
        criticalBar.classList.remove('flash-twice');
        void criticalBar.offsetWidth;
        criticalBar.classList.add('flash-twice');
        beep(2, 140, 120, 988);
        criticalBar.addEventListener('animationend', () => {
          criticalBar.classList.remove('flash-twice');
        }, { once: true });
      }

      cleanupCritical();
    } catch (e) {
      console.error('Critical fetch failed:', e);
    }
  }

  /* ===== Geocoding (single copy) ===== */
  const GEOCODE_RATE_MS = 1200;
  const GEOCODE_TTL_MS  = 7 * 24 * 60 * 60 * 1000;  // 7 days cache
  const GEOCODE_BOUNDS  = { minLon: -73.90, minLat: 40.50, maxLon: -73.40, maxLat: 40.90 };

  const geoCache = {
    get(key) {
      try {
        const raw = localStorage.getItem('geo_'+key);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || (obj.t && (Date.now()-obj.t) > GEOCODE_TTL_MS)) return null;
        return obj;
      } catch { return null; }
    },
    set(key, lat, lng) {
      try { localStorage.setItem('geo_'+key, JSON.stringify({lat,lng,t:Date.now()})); } catch {}
    }
  };

  const geocodeQueue = []; // items: { key, query, onResult }
  let geocodeTimer = null;

  function enqueueGeocode(key, query, onResult) {
    if (geocodeQueue.find(q => q.key === key)) return;
    geocodeQueue.push({ key, query, onResult });
    if (!geocodeTimer) geocodeTimer = setInterval(processGeocodeQueue, GEOCODE_RATE_MS);
  }

  async function processGeocodeQueue() {
    if (!geocodeQueue.length) {
      clearInterval(geocodeTimer);
      geocodeTimer = null;
      return;
    }
    const job = geocodeQueue.shift();
    try {
      const { key, query, onResult } = job;

      const cached = geoCache.get(key);
      if (cached && isFinite(cached.lat) && isFinite(cached.lng)) {
        onResult(cached.lat, cached.lng);
        return;
      }

      const url = new URL('https://nominatim.openstreetmap.org/search');
      url.searchParams.set('format', 'json');
      url.searchParams.set('q', query);
      url.searchParams.set('countrycodes', 'us');
      url.searchParams.set('addressdetails', '0');
      url.searchParams.set('limit', '1');
      url.searchParams.set('viewbox', `${GEOCODE_BOUNDS.minLon},${GEOCODE_BOUNDS.maxLat},${GEOCODE_BOUNDS.maxLon},${GEOCODE_BOUNDS.minLat}`);
      url.searchParams.set('bounded', '1');
      url.searchParams.set('accept-language', 'en');

      const res = await fetch(url.toString(), { headers: { 'Accept': 'application/json' }});
      if (!res.ok) throw new Error('HTTP '+res.status);
      const arr = await res.json();
      if (Array.isArray(arr) && arr.length) {
        const lat = Number(arr[0].lat), lng = Number(arr[0].lon);
        if (isFinite(lat) && isFinite(lng)) {
          geoCache.set(key, lat, lng);
          onResult(lat, lng);
          return;
        }
      }
      onResult(null, null);
    } catch (e) {
      console.warn('Geocode failed:', e);
      job.onResult(null, null);
    }
  }

  function maybeGeocodeAndDropPin_Normal(a, id) {
    if (typeof a.lat === 'number' && typeof a.lng === 'number') return;
    const entry = live.get(id);
    if (!entry) return;
    if ((entry.expiresAt - Date.now()) < 30000) return;
    const addr = `${a.location || ''}${a.city ? ', '+a.city : ''}, NY`.trim();
    if (!addr || addr === ', NY') return;
    const cacheKey = addr.toLowerCase();
    enqueueGeocode(cacheKey, addr, (lat, lng) => {
      if (lat == null || lng == null) return;
      const curr = live.get(id);
      if (!curr || curr.expiresAt <= Date.now()) return;
      const color = colorFor(a);
      const marker = makeMarker(lat, lng, color, a);
      curr.marker = marker;
    });
  }

  function maybeGeocodeAndDropPin_Critical(a, id) {
    const entry = critLive.get(id);
    if (!entry) return;
    if ((entry.expiresAt - Date.now()) < 30000) return;
    const addr = `${a.location || ''}${a.city ? ', '+a.city : ''}, NY`.trim();
    if (!addr || addr === ', NY') return;
    const cacheKey = 'crit:'+addr.toLowerCase();
    enqueueGeocode(cacheKey, addr, (lat, lng) => {
      if (lat == null || lng == null) return;
      const curr = critLive.get(id);
      if (!curr || curr.expiresAt <= Date.now()) return;
      const marker = makeFireMarker(lat, lng, a);
      curr.marker = marker;
    });
  }

  /* ===== Left Note Pad (user-editable, with UI) ===== */
  const BULLETIN_KEY = 'bulletin_text_v1';
  const bulletinEl   = document.getElementById('bulletin');
  const saveBtn      = document.getElementById('bulletinSave');
  const revertBtn    = document.getElementById('bulletinRevert');
  const clearBtn     = document.getElementById('bulletinClear');
  const statusEl     = document.getElementById('bulletinStatus');

  let bulletinDirty = false;

  function bulletinLoad() {
    try {
      const saved = localStorage.getItem(BULLETIN_KEY);
      if (saved) bulletinEl.innerHTML = saved;
    } catch {}
    statusEl.textContent = '';
  }
  function bulletinSave() {
    try {
      localStorage.setItem(BULLETIN_KEY, bulletinEl.innerHTML);
      bulletinDirty = false;
      const t = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false});
      statusEl.textContent = `Saved ${t}`;
      setTimeout(() => (statusEl.textContent = ''), 3000);
    } catch (e) {
      statusEl.textContent = 'Save failed';
    }
  }
  function bulletinClear() {
    if (!confirm('Clear bulletin and remove saved copy?')) return;
    bulletinEl.innerHTML = '';
    try { localStorage.removeItem(BULLETIN_KEY); } catch {}
    statusEl.textContent = 'Cleared';
    setTimeout(() => (statusEl.textContent = ''), 2000);
  }
  function bulletinRevert() { bulletinLoad(); }
  bulletinEl.addEventListener('input', () => { bulletinDirty = true; });
  saveBtn.addEventListener('click', bulletinSave);
  revertBtn.addEventListener('click', bulletinRevert);
  clearBtn.addEventListener('click', bulletinClear);
  setInterval(() => { if (bulletinDirty) bulletinSave(); }, 10000);
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
      e.preventDefault();
      bulletinSave();
    }
  });

  /* ===== Right Board (independent, code-controlled only) ===== */
  const BULLETIN_READ_KEY = 'bulletin_read_text_v1';
  const readEl = document.getElementById('bulletinRead');

  function readBoardLoad() {
    try {
      const saved = localStorage.getItem(BULLETIN_READ_KEY);
      if (saved) readEl.innerHTML = saved;
    } catch {}
  }

  function setReadBoard(html) {
    try {
      localStorage.setItem(BULLETIN_READ_KEY, html);
      readEl.innerHTML = html;
    } catch {}
  }
  window.setReadBoard = setReadBoard;

  /* ===== TEMPORARY LAYOUT DRAG (no persistence) ===== */
  const mainEl = document.querySelector('main');
  const editBtn = document.getElementById('editLayoutBtn');
  const resetBtn = document.getElementById('resetLayoutBtn');
  let editOn = false;
  let dragSrcEl = null;

  function setEditMode(on) {
    document.body.classList.toggle('edit-mode', on);
    Array.from(mainEl.children).forEach(card => {
      if (card.classList.contains('card')) card.draggable = !!on;
    });
    resetBtn.style.display = on ? 'inline-block' : 'none';
    if (!on && typeof map?.invalidateSize === 'function') {
      setTimeout(() => map.invalidateSize(), 50);
    }
  }

  function handleDragStart(e) {
    const card = e.currentTarget;
    dragSrcEl = card;
    card.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', card.dataset.cardId || '');
  }
  function handleDragEnd(e) {
    e.currentTarget.classList.remove('dragging');
    dragSrcEl = null;
    if (typeof map?.invalidateSize === 'function') {
      setTimeout(() => map.invalidateSize(), 50);
    }
  }
  function handleDragOver(e) {
    if (!editOn) return;
    e.preventDefault(); // allow drop
    const target = e.target.closest('.card');
    if (!target || target === dragSrcEl) return;
    const rect = target.getBoundingClientRect();
    const before = (e.clientY - rect.top) < rect.height / 2;
    if (before) mainEl.insertBefore(dragSrcEl, target);
    else mainEl.insertBefore(dragSrcEl, target.nextSibling);
  }
  function initDragAndDrop() {
    mainEl.addEventListener('dragover', handleDragOver);
    Array.from(mainEl.children).forEach(card => {
      if (!card.classList.contains('card')) return;
      card.addEventListener('dragstart', handleDragStart);
      card.addEventListener('dragend', handleDragEnd);
    });
  }

  if (editBtn) {
    editBtn.addEventListener('click', () => {
      editOn = !editOn;
      editBtn.textContent = editOn ? 'Done' : 'Edit layout';
      setEditMode(editOn);
      if (editOn) initDragAndDrop();
    });
  }
  if (resetBtn) {
    resetBtn.addEventListener('click', () => { location.reload(); });
  }

  /* ===== FULLSCREEN (Note Pad & Map) ===== */
  const noteTitle = document.getElementById('notePadTitle');
  const mapTitle  = document.getElementById('mapTitle');
  let fsCard = null;     // currently fullscreen card
  let fsBackdrop = null;

  function enterFullscreen(card) {
    if (fsCard) exitFullscreen(); // just in case
    fsBackdrop = document.createElement('div');
    fsBackdrop.id = 'fsBackdrop';
    document.body.appendChild(fsBackdrop);
    document.body.classList.add('fs-open');

    card.classList.add('is-fullscreen');
    fsCard = card;

    fsBackdrop.addEventListener('click', exitFullscreen, { once: true });
    document.addEventListener('keydown', escListener);
    // Map needs reflow if it's the map card
    if (card.contains(mapEl) && typeof map?.invalidateSize === 'function') {
      setTimeout(() => map.invalidateSize(), 80);
    }
  }
  function escListener(e) {
    if (e.key === 'Escape') exitFullscreen();
  }
  function exitFullscreen() {
    if (!fsCard) return;
    fsCard.classList.remove('is-fullscreen');
    if (fsBackdrop && fsBackdrop.parentNode) fsBackdrop.parentNode.removeChild(fsBackdrop);
    fsBackdrop = null;
    document.body.classList.remove('fs-open');
    document.removeEventListener('keydown', escListener);
    // Reflow map on exit too
    if (typeof map?.invalidateSize === 'function') {
      setTimeout(() => map.invalidateSize(), 80);
    }
    fsCard = null;
  }
  function toggleFS(card) {
    if (fsCard === card) exitFullscreen();
    else enterFullscreen(card);
  }

  // Clickable titles
  if (noteTitle) {
    noteTitle.addEventListener('click', (e) => {
      // ignore clicks on the toolbar below; title click only
      toggleFS(noteTitle.closest('.card'));
    });
  }
  if (mapTitle) {
    mapTitle.addEventListener('click', () => toggleFS(mapTitle.closest('.card')));
  }

  /* ===== Start everything ===== */
  function init() {
    bulletinLoad();     // left-board load
    readBoardLoad();    // right-board load
    startPolling();     // normal feed
    setInterval(tickCritical, 15000); // critical feed
    tickCritical();
  }
  init();
</script>
</body>
</html>
